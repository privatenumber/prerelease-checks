"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }var _chunkF4DAITINjs = require('./chunk-F4DAITIN.js');var a=_chunkF4DAITINjs.d.call(void 0, _chunkF4DAITINjs.a.call(void 0, )),i=_chunkF4DAITINjs.d.call(void 0, _chunkF4DAITINjs.e.call(void 0, ));var _assert = require('assert'); var _assert2 = _interopRequireDefault(_assert);var _listr = require('listr'); var _listr2 = _interopRequireDefault(_listr);var V=async()=>{try{return await(0,i.default)("git",["rev-parse","--is-inside-work-tree"]),!0}catch (e2){return!1}},h=async()=>{let{stdout:e}=await(0,i.default)("git",["symbolic-ref","--short","-q","HEAD"]);return e},f=async()=>{let{stdout:e}=await(0,i.default)("git",["version"]),t=/git version (\d+\.\d+\.\d+).*/.exec(e);return t==null?void 0:t[1]},y=async()=>{try{await(0,i.default)("git",["ls-remote","origin","HEAD"])}catch(e){let t=e.stderr.match(/fatal: .+/);throw new Error(t)}},d=async()=>{let{stdout:e}=await(0,i.default)("git",["status","--porcelain"]);return e.split(`
`).filter(Boolean)},g=async e=>{try{await(0,i.default)("git",["fetch","origin",e])}catch (e3){throw new Error(`Failed to fetch origin/${e}`)}let{stdout:t}=await(0,i.default)("git",["status"]),r=t.match(/Your branch is (ahead|behind) .*/);return r?r[0]:!1},m=new (0, _listr2.default)([{title:"Verify Git version",async task(e,t){t.title="Verifying Git version...";let r=await f(),o=a.default.satisfies(r,e.requiredGit,{includePrerelease:!0});_assert2.default.call(void 0, o,`Git version expected to satisfiy ${e.requiredGit}. Found ${r}`),t.title=`Git version is ${r}`}},{title:"Verify working directory is clean",async task(e,t){t.title="Verifying working directory is clean...";let r=await d();_assert2.default.call(void 0, r.length===0,`Expected working directory to be clean but found ${r.length} file${r.length>1?"s":""}`),t.title="Working directory is clean"}},{title:"Verify current branch is release branch",async task(e,t){t.title="Verifying current branch is release branch...";let r=await h();_assert2.default.call(void 0, e.releaseBranch===r,`Must be on release branch "${e.releaseBranch}". Found "${r}".`),t.title=`Current branch is "${e.releaseBranch}"`,e.gitCurrentBranchname=r}},{title:"Verify remote head exists",async task(e,t){t.title="Verifying remote head exists...",await y(),t.title="Remote head exists"}},{title:"Verify current branch is identical to upstream",async task(e,t){t.title="Verifying current branch is identical to upstream...";let r=await g(e.gitCurrentBranchname);if(r)throw new Error(r);t.title="Current branch is identical to upstream"}}]),v= exports.b =m;exports.a = V; exports.b = v;
